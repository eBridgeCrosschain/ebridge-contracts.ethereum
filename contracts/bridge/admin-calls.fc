;; messages from admin

() handle_admin_messages(int op, int query_id, int my_balance, int msg_value, slice in_msg_body) impure inline {
    if (op == init_code_upgrade) { 
        (int end_code, _, int end_admin, slice admin) = unpack_temp_upgrade(storage::temp_upgrade);
        throw_unless(INVALID_CALL, end_code == 0); ;; upgrade already in progress
        storage::temp_upgrade = pack_temp_upgrade(now() + SEVENDAYS,  in_msg_body~load_ref(), end_admin, admin);
        save_storage();
        return ();
    }

    if (op == init_admin_upgrade) { 
        (int end_code, cell new_code, int end_admin, _) = unpack_temp_upgrade(storage::temp_upgrade);
        throw_unless(INVALID_CALL, end_admin == 0); ;; upgrade already in progress
        storage::temp_upgrade = pack_temp_upgrade(end_code, new_code, now() + TWODAYS, in_msg_body~load_msg_addr());
        save_storage();
        return ();
    }
    
    if (op == cancel_admin_upgrade) { 
        (int end_code, cell code, int end_admin, _) = unpack_temp_upgrade(storage::temp_upgrade);
        throw_unless(INVALID_CALL, end_admin > 0); 
        storage::temp_upgrade = pack_temp_upgrade(end_code, code, 0, HOLE_ADDRESS);
        save_storage();
        return ();
    }

    if (op == cancel_code_upgrade) { 
        (int end_code, _, int end_admin, slice admin) = unpack_temp_upgrade(storage::temp_upgrade);
        throw_unless(INVALID_CALL, end_code > 0); 
        storage::temp_upgrade = pack_temp_upgrade(0, empty_cell(), end_admin, admin);
        save_storage();
        return ();
    }

    ;; valid for both upgrades
    if (op == finalize_upgrades) { 
        (int end_code, cell new_code, int end_admin, slice new_admin) = unpack_temp_upgrade(storage::temp_upgrade);
        throw_unless(INVALID_CALL, (end_code + end_admin) > 0); ;; make sure at least one upgrade process is in progress

        if ((end_code > 0) & (now() >= end_code)) {
            set_code(new_code);
            end_code = 0;
            new_code = empty_cell();
        }

        if ((end_admin > 0) & (now() >= end_admin)) {
            storage::admin_address = new_admin;
            end_admin = 0;
            new_admin = HOLE_ADDRESS;
        }

        storage::temp_upgrade = pack_temp_upgrade(end_code, new_code, end_admin, new_admin);
        save_storage();
        return ();
    }

    if (op == add_jetton_whitelist) {
        int target_chain_id = in_msg_body~load_uint(32);
        slice ref_cs = in_msg_body;
        int has_refs = 0;
        do {
            slice whitelist_jetton_address = ref_cs~load_msg_addr();
            (int wc, int jetton_address_hash) = parse_std_addr(whitelist_jetton_address);
            var key_builder = begin_cell()
                    .store_uint(wc,8)
                    .store_uint(target_chain_id,32)
                    .store_uint(jetton_address_hash,256)
                    .end_cell();
            var key_hash = cell_hash(key_builder);
            storage::jetton_whitelist_dic~idict_set_builder(KEY_LENGTH, key_hash, begin_cell().store_int(-1, 1));
            has_refs = ref_cs.slice_refs() > 0;
            if (has_refs) {
                cell ref = ref_cs~load_ref();
                ref_cs = ref.begin_parse();
            }
        } until (~ has_refs);
        save_storage();
    }

    if (op == set_bridge_pool) {
        slice jetton_address = in_msg_body~load_msg_addr();
        slice pool_address = in_msg_body~load_msg_addr();
        storage::bridge_pool_address_dic~dict_set(KEY_LENGTH,jetton_address,pool_address);
        save_storage();
    }

    if (op == change_pause_controller) {
        slice pause_controller = in_msg_body~load_msg_addr();
        storage::pause_controller = pause_controller;
        save_storage();
    }

    throw(WRONG_OP);
}